import { Middleware, TurnContext, ActivityTypes, Activity, CloudAdapter } from 'botbuilder';
import { MessageFactory } from 'botbuilder';
import { Util } from './util';
import { InterceptorConversation, InterceptorState, InterceptorStor } from './interceptor.interface';
import { Transcript } from './mitel-workflow-generic.interface';



/**
 * Inspects Activities and manages handoff between bot and human agent.
 * See https://learn.microsoft.com/en-us/microsoft-copilot-studio/configure-generic-handoff
 */
class InterceptorMiddleware implements Middleware {
    constructor(private conversations: InterceptorStor, private mitelUrl: string) {
        if (!conversations) {
            throw new Error('InterceptorMiddleware() conversations is required');
        }
        if (!mitelUrl) {
            throw new Error('InterceptorMiddleware() mitelUrl is required');
        }
    }

    async onTurn(context: TurnContext, next: () => Promise<void>): Promise<void> {

        await this.updateState(context);
        
        this.monitorBotOutgoingEvents(context);
    
        if ([ActivityTypes.ConversationUpdate, ActivityTypes.Message].includes(context.activity.type as ActivityTypes)) {
            const isAgent = await this.isFromAgent(context);
            if (isAgent) {
                await this.manageAgent(context, next);
                return;
            } else {
                await this.manageClient(context, next);
                return;
            } 
        } else {
            // All other activities are to pass through.
            // This is especialy critical for ContinueConversation activities, which are generated by sendProactiveMessage()
            await next();
        }   
    }

    private async sendToMitel(data: any, context?: TurnContext): Promise<Response> {
        const response = await fetch(this.mitelUrl, { method: 'POST', body: JSON.stringify(data) });
        if (context) {
            // Send a trace activity, which will be displayed in Bot Framework Emulator
            await  context.sendTraceActivity(
                'Trace',
                {url: response.url, status: response.status, data},
                '',
                'sendToMitel()',
            );
        }
        return response;
    }

    /**
     * 
     * @param id 
     * @returns
     */
    private getConversation(id: string): Promise<InterceptorConversation | undefined>{
        return this.conversations.get(id);
    }
    /**
     * 
     * @param id 
     * @returns existing or new Conversation
     */
    private async createConversation(id: string, context: TurnContext): Promise<InterceptorConversation> {
        const conversationReference = TurnContext.getConversationReference(context.activity);
        const existing = await this.getConversation(id);
        if (existing) {
            return existing;
        }
        return this.conversations.set(id, {state: InterceptorState.bot, conversationReference});
    }

    private async updateConversation(id: string, conversation: Partial<InterceptorConversation>) {
        const existing = await this.getConversation(id);
        if (existing) {
            this.conversations.set(id, { ...existing, ...conversation });
        }
    }

    private async updateState(context: TurnContext) {
        if (context.activity.from?.role === 'agent') {
            const conversation = await this.getConversation(context.activity.conversation.id);
            if (!conversation) {
                console.error('InterceptorMiddleware.updateState() no conversation found for agent', context.activity);
                return;
            }
        } else {
            // will create a conversation record if one does not already exist
            await this.createConversation(context.activity.conversation.id, context);
        }
    }

    private async isFromAgent(context: TurnContext): Promise<boolean> {
        const conversation = await this.getConversation(context.activity.conversation.id);
        return conversation && context.activity.from?.role === 'agent';
    }

    private async manageAgent(context: TurnContext, next: () => Promise<void>): undefined | Promise<void> {
        const conversation = await this.getConversation(context.activity.conversation.id);

        if (conversation) {
            switch(context.activity.type) {
                case ActivityTypes.Message:
                    if (conversation.state === InterceptorState.bot){
                        // drop the message and warn the agent
                        let event = {
                            type: ActivityTypes.Message,
                            conversation: context.activity.conversation,
                            from: conversation.conversationReference?.user,
                            membersRemoved: [context.activity.from],
                            text: 'Sorry, the client has left this conversation. Goodbye.'
                        }
                        this.sendToMitel(event);
                    } else {
                        // Send to Client
                        Util.sendProactiveActivity(context.adapter as CloudAdapter, conversation.conversationReference, context.activity);
                    }
                    break;
                case ActivityTypes.ConversationUpdate:
                    context.activity.membersAdded?.forEach(async m => {
                        if (m.role === 'agent') {
                            const conv = await this.updateConversation(context.activity.conversation.id, { state: InterceptorState.agent });
                            Util.sendProactiveMessage(context.adapter as CloudAdapter, conversation.conversationReference, `${m.name} has joined the conversation`);
                        }
                    });
                    context.activity.membersRemoved?.forEach(async m => {
                        if (m.role === 'agent') {
                            await this.updateConversation(context.activity.conversation.id, { state: InterceptorState.bot });
                            Util.sendProactiveMessage(context.adapter as CloudAdapter, conversation.conversationReference, `${m.name} has left the conversation`);
                        }
                    });
                    await next(); // pass on to next in chain
                    break;
                default:
                    console.log(`InterceptorMiddleware.manageAgent() unhandled activity type ${context.activity.type}`, context.activity);
            }
        } else {
            console.log('InterceptorMiddleware.manageAgent() no conversation found for agent', context.activity);
        }
        return;
        // This could also be an agent join or leave event, probably via a conversationUpdate event  TODO
    }

    /**
     * 
     * @param context 
     * @param next will call next() if the message is not handled
     * @returns 
     */
    private async manageClient(context: TurnContext, next: () => Promise<void>): undefined | Promise<void> {

        if (context.activity.type !== ActivityTypes.Message) {
            await next();
            return;
        }

        const conversation = await this.getConversation(context.activity.conversation.id);
        if (!conversation) {
            console.log('InterceptorMiddleware.manageClient() no conversation found for client', context.activity);
            return;
        }
        switch (conversation.state) {
            case InterceptorState.agent:
                const response = await this.sendToMitel(context.activity, context);
                if (!(response.status >= 200 && response.status <= 299)) {
                    console.log(`InterceptorMiddleware.manageClient() Failed to send message to Agent`,response);
                    context.sendActivity(`Sorry, I am unable to send a message to the agent at this time. ${JSON.stringify(response)}`);
                }
                break;  // don't call next() bc we just handled it
            case InterceptorState.bot:
                await next(); // pass on to next in chain
                break;
            case InterceptorState.queued:
                if (context.activity.text?.toLowerCase()?.includes('@bot')) {
                    await this.updateConversation(context.activity.conversation.id, { state: InterceptorState.bot });
                    await context.sendActivity('Switching you back to the bot');
                    let event = {
                        type: ActivityTypes.ConversationUpdate,
                        conversation: context.activity.conversation,
                        from: context.activity.from,
                        membersRemoved: [context.activity.from],
                    }
                    const response = await this.sendToMitel(event, context);
                    if (!(response.status >= 200 && response.status <= 299)) {
                        console.log(`InterceptorMiddleware.manageClient() Failed to send message to Agent`,response);
                        context.sendActivity(`Sorry, I am unable to send a message to the agent at this time. ${JSON.stringify(response)}`);
                    }
                } else {
                    await context.sendActivity(`You are in the queue. We are waiting for a human operator. Type @bot to return to the bot conv=${context.activity.conversation.id}`);
                }
                break;
        }
        return;
    }

    /**
     * Set up a listener for outgoing activities sent during this turn
     * (we want to detect the handoff requested event)
     * @param context 
     */
    private monitorBotOutgoingEvents(context: TurnContext) {
        context.onSendActivities(async (ctx: TurnContext, activities: Partial<Activity>[], nextSend) => {
            for (const activity of activities) {
                if (activity.type === ActivityTypes.Event && activity.name === 'handoff.initiate') {
                    // console.log(`InterceptorMiddleware() Handoff to human operator initiated conv=${context.activity.conversation.id}`, activity);
                    
                    let event = {
                        type: 'handoff',
                        conversation: context.activity.conversation,
                        from: context.activity.from,
                        transcript: this.getTranscript(activity),
                        custom: activity.value
                    }
                    const response = await this.sendToMitel(event, context);
                    if (!(response.status >= 200 && response.status <= 299)) {
                        console.log(`InterceptorMiddleware.monitorBotOutgoingEvents() Failed to send message to Agent`,response);
                    }
                    // Add user to the handoff queue
                    const conversationReference = TurnContext.getConversationReference(context.activity)

                    await this.updateConversation(context.activity.conversation.id, { state: InterceptorState.queued, conversationReference });
                    
                    // Notify the user that they've been added to the queue
                    const message = 'You have been added to the queue for a human operator. Please wait.';
                    await ctx.sendActivity(MessageFactory.text(message, message));
                }
            }
            // Continue sending the activities
            return await nextSend();
        });
    }


    private getTranscript(activity: Partial<Activity>): Transcript[] {
        let transcript = [];
        if (activity.type === ActivityTypes.Event && activity.name === 'handoff.initiate') {
            const botTranscript = activity.attachments?.find(a => a.name.toLowerCase() === 'transcript')?.content;
            if (botTranscript) {
                transcript = botTranscript.map( t => ({
                    from: t.from,
                    to: t.recipient,
                    text: t.text,
                    textFormat: t.textFormat,
                    timestamp: t.timestamp,
                })).sort((x, y) => {
                    // Cronological order, oldest 1st
                    return new Date(x.timestamp) > new Date(y.timestamp) ? 1 : -1
                }) ?? [];
            }
        }
        return transcript;
    }

}

export default InterceptorMiddleware;